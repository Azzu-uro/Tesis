# -*- coding: utf-8 -*-
"""Plots_aceleracion_distancia.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1aWWwHER2hn8L5Ckkrncq-IGcowkL4EzE
"""

# Commented out IPython magic to ensure Python compatibility.
# %%capture
# !pip install adjustText # Instala la librería si no la tienes

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import statsmodels.formula.api as smf
from adjustText import adjust_text

excel_file = '/content/Aceleracion_maxima_vs_distancia_epicentral.xlsx'
total = pd.read_excel(excel_file, sheet_name=None, skiprows=1)

# Función para la aceleración
def plot_aceleracion(df, title, ajuste, fit_stations):
  plt.figure(figsize=(8, 6), dpi=300)

  ax = sns.scatterplot(x='Distancia',
                       y='Aceleracion',
                       data=df,
                       hue='Zona',
                       style = 'Zona',
                       palette={1: 'green', 2: 'orange', 3: 'red'},
                       markers={1: 'o', 2: '^', 3: 's'},
                       s=100)

  ax.set(xscale="log", yscale="log")
  #ax.legend_.remove()

  # Plot fit
  """
  intercept = ajuste.params['Intercept']
  slope = ajuste.params['logDistancia']
  x_values = np.logspace(np.log10(df['Distancia'].min()), np.log10(df['Distancia'].max()), 100)
  y_values =13.2*x_values**(-0.83)  #10**(intercept + slope * np.log10(x_values))
  plt.plot(x_values, y_values, color='red', label='Regression Line')
  """
  label = "" #f'Ajuste: Amax = 13.2 * Distancia^(0.83)' #f'Ajuste: Amax = 10^({intercept:.2f}) * Distancia^({slope:.2f})'

  plt.xlabel('Distancia epicentral [Km]')
  plt.ylabel('Aceleración máxima [Gal]')
  plt.title(f'Aceleración máxima vs distancia epicentral para el sismo {title}')
  plt.text(0.4, 0.9, label, transform=ax.transAxes, fontsize=12)

  ax.grid(which='both')
  ax.set_axisbelow(True)
  handles, labels = ax.get_legend_handles_labels()

  texts = []
  for i, row in df.iterrows():  # Iterar sobre las filas del DataFrame
    station_label = row['Estacion']
    if row['Estacion'] not in fit_stations:  # Check against fit_stations
        station_label += ''
    texts.append(plt.text(row['Distancia'], row['Aceleracion'], station_label, ha='left', va='bottom'))

  adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

  plt.savefig(f'{title}_Aceleracion.png', dpi=300)
  plt.show()

# Función para la frecuencia
def plot_frecuencia(df, title, ajuste, fit_stations):
  plt.figure(figsize=(10, 6), dpi=300)

  ax = sns.scatterplot(x='Distancia',
                       y='Frecuencia',
                       data=df,
                       hue='Zona',
                       style = 'Zona',
                       palette={1: 'green', 2: 'orange', 3: 'red'},
                       markers={1: 'o', 2: '^', 3: 's'},
                       s=100)
  #ax.set( xscale="log", yscale="log")
  #ax.legend_.remove()

  # Plot fit
  intercept = ajuste.params['Intercept']
  slope = ajuste.params['logDistancia']
  x_values = np.logspace(np.log10(df['Distancia'].min()-1), np.log10(df['Distancia'].max()), 100)
  y_values = 10**(intercept + slope * np.log10(x_values))
  plt.plot(x_values, y_values, color='red', label='Regression Line')

  label = f'Ajuste: y = 10^({intercept:.2f}) * x^({slope:.2f})'

  plt.xlabel('Distancia epicentral [Km]')
  plt.ylabel('Frecuencia dominante [Hz]')
  plt.title(f'Frecuencia dominante vs distancia epicentral para el sismo {title}')
  plt.text(0.6, 0.9, label, transform=ax.transAxes, fontsize=12)

  ax.grid(which='both')
  ax.set_axisbelow(True)
  handles, labels = ax.get_legend_handles_labels()

  texts = []
  for i, row in df.iterrows():  # Iterar sobre las filas del DataFrame
    station_label = row['Estacion']
    if row['Estacion'] not in fit_stations:  # Check against fit_stations
        station_label += '*'
    texts.append(plt.text(row['Distancia'], row['Frecuencia'], station_label, ha='left', va='bottom'))

  adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

  plt.savefig(f'{title}_frecuencia.png', dpi=300)
  plt.show()

# Función para Frecuencias vs Aceleraciones
def plot_frecuencia_vs_aceleracion(df, title, ajuste, fit_stations):
  plt.figure(figsize=(10, 6), dpi=300)

  ax = sns.scatterplot(x='Aceleracion',
                       y='Frecuencia',
                       data=df,
                       hue='Zona',
                       style = 'Zona',
                       palette={1: 'green', 2: 'orange', 3: 'red'},
                       markers={1: 'o', 2: '^', 3: 's'},
                       s=100)
  #ax.set(xscale="log", yscale="log")
  #ax.legend_.remove()


  # Plot fit
  intercept = ajuste.params['Intercept']
  slope = ajuste.params['Aceleracion']
  r_squared = ajuste.rsquared
  x_values = np.arange(df['Aceleracion'].min(), df['Aceleracion'].max()+4)
  y_values =  slope*x_values + intercept
  plt.plot(x_values, y_values, color='red', label='Regression Line')

  label = f'Ajuste: y = {slope:.2f} * x + {intercept:.2f} ($R^2$ = {r_squared:.2f})'

  plt.xlabel('Aceleración máxima [Gal]')
  plt.ylabel('Frecuencia dominante [Hz]')
  plt.title(f'Aceleración máxima vs frecuencia dominante para el sismo {title}')
  plt.text(0.4, 0.9, label, transform=ax.transAxes, fontsize=12)


  ax.grid(which='both')
  ax.set_axisbelow(True)
  handles, labels = ax.get_legend_handles_labels()

  texts = []
  for i, row in df.iterrows():  # Iterar sobre las filas del DataFrame
    station_label = row['Estacion']
    if row['Estacion'] not in fit_stations:  # Check against fit_stations
        station_label += '*'
    texts.append(plt.text(row['Aceleracion'], row['Frecuencia'], station_label, ha='left', va='bottom'))


  adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

  plt.savefig(f'{title}_FrecVsAceleracion.png', dpi=300)
  plt.show()

"""## 2014-12-01

No se toman en cuenta las estaciones TACY y CUP5.

Para ninguno los ajustes no se toma en cuenta CB43.
"""

# Definición de la tabla de trabajo
df1 = total['2014-12-01']
df1 = df1[:15]
df1

# Limpieza de la tabla TACY y CUP5 por falta de datos
df1 = df1[(df1['Estacion'] != 'TACY') & (df1['Estacion'] != 'CUP5')]
df1;

# Seteo de tipos
df1 = df1.astype({'Estacion': str, 'Frecuencia': float, 'Aceleracion': float, 'Distancia': float})
df1['Zona'] = pd.Categorical(df1['Zona'])
#df1.info()

# Transformación de variables
df1['logDistancia']     = np.log10(df1['Distancia'])
df1['logAceleracion']   = np.log10(df1['Aceleracion'])
df1['logFrecuencia']    = np.log10(df1['Frecuencia'])
df1['ErrorDistancia']   = 0.01
df1['ErrorAceleracion'] = 0.01
df1['ErrorFrecuencia']  = 0.01
df1;

df1_fit = df1[(df1['Estacion'] != 'CB43') ]
fit_stations_1 = df1_fit['Estacion'].values  # Estaciones del ajuste

model_1a = smf.ols('logAceleracion ~ logDistancia', data=df1_fit)
model_1b = smf.ols('logFrecuencia ~ logDistancia', data=df1_fit)
model_1c = smf.ols('Frecuencia ~ Aceleracion', data=df1_fit)

results_1a = model_1a.fit()
results_1b = model_1b.fit()
results_1c = model_1c.fit()

plot_aceleracion(df1, '2014-12-01', results_1a, fit_stations_1)
#plot_frecuencia(df1, '2014-12-01', results_1b, fit_stations_1)
#plot_frecuencia_vs_aceleracion(df1,'2014-12-01', results_1c, fit_stations_1)

"""# 2018-02-13

"""

# Definición de la tabla de trabajo
df2 = total['2018-02-13']
df2 = df2[:6];

# Limpieza de la tabla
#df2 = df2[df2['Estacion'] != 'TACY']
df2

# Seteo de tipos
df2 = df2.astype({'Estacion': str, 'Frecuencia': float, 'Aceleracion': float, 'Distancia': float})
df2['Zona'] = pd.Categorical(df2['Zona'])
#df1.info()

# Transformación de variables
df2['logDistancia']     = np.log10(df2['Distancia'])
df2['logAceleracion']   = np.log10(df2['Aceleracion'])
df2['logFrecuencia']    = np.log10(df2['Frecuencia'])
df2['ErrorDistancia']   = 0.01
df2['ErrorAceleracion'] = 0.01
df2['ErrorFrecuencia']  = 0.01
df2;

df2_fit = df2[(df2['Estacion'] != 'TACY') ]
fit_stations_2 = df2_fit['Estacion'].values  # Estaciones del ajuste

model_2a = smf.ols('logAceleracion ~ logDistancia', data=df2)
model_2b = smf.ols('logFrecuencia ~ logDistancia', data=df2)
model_2c = smf.ols('Frecuencia ~ Aceleracion', data=df2)

results_2a = model_2a.fit()
results_2b = model_2b.fit()
results_2c = model_2c.fit()

plot_aceleracion(df2, '2018-02-13', results_2a, fit_stations_2)
#plot_frecuencia(df2, '2018-02-13', results_2b, fit_stations_2)
#plot_frecuencia_vs_aceleracion(df2,'2018-02-13', results_2c, fit_stations_2)

"""# 2019-07-17

"""

# Definición de la tabla de trabajo
df3 = total['2019-07-17']
df3 = df3[:15]
df3

# Limpieza de la tabla
#df3 = df3[df3['Estacion'] != 'MT50']
df3;

# Seteo de tipos
df3 = df3.astype({'Estacion': str, 'Frecuencia': float, 'Aceleracion': float, 'Distancia': float})
df3['Zona'] = pd.Categorical(df3['Zona'])
#df3.info()

# Transformación de variables
df3['logDistancia']     = np.log10(df3['Distancia'])
df3['logAceleracion']   = np.log10(df3['Aceleracion'])
df3['logFrecuencia']    = np.log10(df3['Frecuencia'])
df3['ErrorDistancia']   = 0.01
df3['ErrorAceleracion'] = 0.01
df3['ErrorFrecuencia']  = 0.01
df3;

df3_fit = df3[(df3['Estacion'] != 'MT50') ]
fit_stations_3 = df3_fit['Estacion'].values  # Estaciones del ajuste

model_3a = smf.ols('logAceleracion ~ logDistancia', data=df3)
model_3b = smf.ols('logFrecuencia ~ logDistancia', data=df3)
model_3c = smf.ols('Frecuencia ~ Aceleracion', data=df3)

results_3a = model_3a.fit()
results_3b = model_3b.fit()
results_3c = model_3c.fit()

plot_aceleracion(df3, '2019-07-17', results_3a, fit_stations_3)
#plot_frecuencia(df3, '2019-07-17', results_3b, fit_stations_3)
#plot_frecuencia_vs_aceleracion(df3,'2019-07-17', results_3c, fit_stations_3)

"""# 2020-06-07"""

# Definición de la tabla de trabajo
df4 = total['2020-06-07']
df4 = df4[:6]
df4

# Limpieza de la tabla
#df4 = df4[(df4['Estacion'] != 'CB43') & (df4['Estacion'] != 'TACY') & (df4['Estacion'] != 'CUP5')]
df4;

# Seteo de tipos
df4 = df4.astype({'Estacion': str, 'Frecuencia': float, 'Aceleracion': float, 'Distancia': float})
df4['Zona'] = pd.Categorical(df4['Zona'])
#df1.info()

# Transformación de variables
df4['logDistancia']     = np.log10(df4['Distancia'])
df4['logAceleracion']   = np.log10(df4['Aceleracion'])
df4['logFrecuencia']    = np.log10(df4['Frecuencia'])
df4['ErrorDistancia']   = 0.01
df4['ErrorAceleracion'] = 0.01
df4['ErrorFrecuencia']  = 0.01
df4;

df4_fit = df4 #df4[(df4['Estacion'] != 'MT50') ]
fit_stations_4 = df4_fit['Estacion'].values  # Estaciones del ajuste

model_4a = smf.ols('logAceleracion ~ logDistancia', data=df4)
model_4b = smf.ols('logFrecuencia ~ logDistancia', data=df4)
model_4c = smf.ols('Frecuencia ~ Aceleracion', data=df4)

results_4a = model_4a.fit()
results_4b = model_4b.fit()
results_4c = model_4c.fit()

plot_aceleracion(df4, '2020-06-07', results_4a, fit_stations_4)
#plot_frecuencia(df4, '2020-06-07', results_4b, fit_stations_4)
#plot_frecuencia_vs_aceleracion(df4,'2020-06-07', results_4c, fit_stations_4)# Definición de la tabla de trabajo











x_linspace = np.linspace(0.1, 1000, 100)
y_linspace = -0.001 * x_linspace + 1000

plt.figure(figsize=(10, 6))
plt.plot(x_linspace, y_linspace)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Plot of y = 13.2 * x^(-0.83)')
plt.grid(True)
plt.xscale('log')
plt.yscale('log')
plt.show()















title = '2014-12-01'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Aceleración máxima  [Gal]', data=df, hue='Estación')

#ax.set(xscale="log", yscale="log")
ax.legend_.remove()

# Get the intercept and slope from results.params
intercept = results.params['Intercept']
slope = results.params['logDistancia']

# Generate x values for the regression line
x_values = np.logspace(np.log10(df['Distancia epicentral [Km]'].min()), np.log10(df['Distancia epicentral [Km]'].max()), 100)

# Calculate y values using the regression equation
y_values = 10**(intercept + slope * np.log10(x_values))

# Plot the regression line on the log-log plot
plt.plot(x_values, y_values, color='red', label='Regression Line')

label = f'Ajuste: y = 10^{intercept:.2f} * x^{slope:.2f}'

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Aceleración máxima [Gal]')
plt.title(f'Aceleración máxima vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()
plt.text(0.6, 0.9, label, transform=ax.transAxes, fontsize=12)

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    # Check if the filtered DataFrame is empty before accessing iloc[0]
    filtered_df = df[df['Estación'] == label][['Distancia epicentral [Km]','Aceleración máxima  [Gal]']]
    if not filtered_df.empty:
        x, y = filtered_df.iloc[0]
        texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}_Amax_loglog.png', dpi=300)
plt.show()



model_f = smf.ols('logFrecuencia ~ logDistancia', data=df)
results_f = model_f.fit()

title = '2014-12-01'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Frecuencia dominante [Hz]', data=df, hue='Estación')
#ax.set( xscale="log", yscale="log")
ax.legend_.remove()


# Get the intercept and slope from results.params
intercept = results_f.params['Intercept']
slope = results_f.params['logDistancia']

# Generate x values for the regression line
x_values = np.logspace(np.log10(df['Distancia epicentral [Km]'].min()-1), np.log10(df['Distancia epicentral [Km]'].max()), 100)

# Calculate y values using the regression equation
y_values = 10**(intercept + slope * np.log10(x_values))

# Plot the regression line on the log-log plot
plt.plot(x_values, y_values, color='red', label='Regression Line')


plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Frecuencia dominante vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    # Check if the filtered DataFrame is empty before accessing iloc[0]
    filtered_df = df[df['Estación'] == label][['Distancia epicentral [Km]','Frecuencia dominante [Hz]']]
    if not filtered_df.empty:
        x, y = filtered_df.iloc[0]
        texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}_frecuencia.png', dpi=300)
plt.show()

model_g = smf.ols('Frecuencia ~ Aceleracion', data=df)
results_g = model_g.fit()

results_g.params

title = '2014-12-01'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Aceleracion', y='Frecuencia', data=df, hue='Estación')
#ax.set(xscale="log", yscale="log")
ax.legend_.remove()


# Get the intercept and slope from results.params
intercept = results_g.params['Intercept']
slope = results_g.params['Aceleracion']

# Generate x values for the regression line
x_values = np.arange(df['Aceleracion'].min(), df['Aceleracion'].max()+4)

# Calculate y values using the regression equation
y_values =  slope*x_values + intercept

# Plot the regression line on the log-log plot
plt.plot(x_values, y_values, color='red', label='Regression Line')


plt.xlabel('Aceleración máxima [Gal]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Aceleración máxima vs frecuencia dominante para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    # Check if the filtered DataFrame is empty before accessing iloc[0]
    filtered_df = df[df['Estación'] == label][['Aceleracion','Frecuencia']]
    if not filtered_df.empty:
        x, y = filtered_df.iloc[0]
        texts.append(plt.text(x, y, label, ha='left', va='bottom'))


adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}.png', dpi=300)
plt.show()



df = total['2018-02-13']
title = '2018-02-13'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Aceleración máxima [Gal]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Aceleración máxima [Gal]')
plt.title(f'Aceleración máxima vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]','Aceleración máxima [Gal]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}.png', dpi=300)
plt.show()

df = total['2019-07-17']
title = '2019-07-17'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Aceleración máxima [Gal]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Aceleración máxima [Gal]')
plt.title(f'Aceleración máxima vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)

handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]', 'Aceleración máxima [Gal]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}.png', dpi=300)
plt.show()

df = total['2020-06-07']
title = '2020-06-07'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Aceleración máxima [Gal]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Aceleración máxima [Gal]')
plt.title(f'Aceleración máxima vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]','Aceleración máxima [Gal]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}.png', dpi=300)
plt.show()





df = total['2018-02-13']
title = '2018-02-13'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Frecuencia dominante [Hz]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Frecuencia dominante vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]','Frecuencia dominante [Hz]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}_frecuencia.png', dpi=300)
plt.show()

df = total['2019-07-17']
title = '2019-07-17'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Frecuencia domiannte [Hz]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Frecuencia dominante vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]','Frecuencia domiannte [Hz]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}_frecuencia.png', dpi=300)
plt.show()

df = total['2020-06-07']
title = '2020-06-07'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Distancia epicentral [Km]', y='Frecuencia dominante [Hz]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Distancia epicentral [Km]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Frecuencia dominante vs distancia epicentral para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Distancia epicentral [Km]','Frecuencia dominante [Hz]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}_frecuencia.png', dpi=300)
plt.show()

df = total['2014-12-01']
title = '2014-12-01'

plt.figure(figsize=(10, 6), dpi=300)

ax = sns.scatterplot(x='Aceleración máxima  [Gal]', y='Frecuencia dominante [Hz]', data=df, hue='Estación')
ax.set(xscale="log", yscale="log")
ax.legend_.remove()

plt.xlabel('Aceleración máxima [Gal]')
plt.ylabel('Frecuencia dominante [Hz]')
plt.title(f'Aceleración máxima vs frecuencia dominante para el sismo {title}')
#xmin, xmax = ax.get_xlim()
#ymin, ymax = ax.get_ylim()

#xticks = 10 ** np.arange(np.floor(np.log10(xmin)), np.ceil(np.log10(xmax)) + 1)
#yticks = 10 ** np.arange(np.floor(np.log10(ymin)), np.ceil(np.log10(ymax)) )

#ax.set_xticks(xticks)
#ax.set_yticks(yticks)

#ax.grid(which='major', axis='both')
ax.grid(which='both')
ax.set_axisbelow(True)
handles, labels = ax.get_legend_handles_labels()

texts = []
for i, label in enumerate(labels):
    x, y = df[df['Estación'] == label][['Aceleración máxima  [Gal]','Frecuencia dominante [Hz]']].iloc[0]
    texts.append(plt.text(x, y, label, ha='left', va='bottom'))

adjust_text(texts, arrowprops=dict(arrowstyle='-', color='black', lw=0.9))

plt.savefig(f'{title}.png', dpi=300)
plt.show()

